<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>MKB City Map</title>

<!-- Leaflet CSS -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
/>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
  }

  #map {
    width: 100%;
    height: 100%;
  }
</style>
</head>

<body>
<div id="map"></div>

<script>
window.onload = function() {

    // 1. Map setup
    var mapWidth = 14208;
    var mapHeight = 14336;
    var bounds = [[0,0], [mapHeight, mapWidth]];

    var map = L.map('map', {
        crs: L.CRS.Simple,
        minZoom: 0,
        maxZoom: 3,
        center: [mapHeight/2, mapWidth/2],
        zoom: 0
    });
    map.fitBounds(bounds);

    // 2. Coordinate conversion (QGIS â†’ Leaflet)
    function qgisToLeaflet(x, y){
        return [mapHeight - y, x];
    }

    // 3. Load tiles dynamically
    fetch('tiles_lookup.json')
    .then(response => response.json())
    .then(tilesLookup => {

        var tileLayer = L.TileLayer.extend({
            getTileUrl: function(coords) {
                var z = coords.z;
                var xIndex = coords.x;
                var yIndex = coords.y;

                if(!tilesLookup[z]) return '';

                var xFolders = Object.keys(tilesLookup[z]);
                if(xIndex < 0 || xIndex >= xFolders.length) return '';
                var xFolder = xFolders[xIndex];

                var yFolders = tilesLookup[z][xFolder];
                if(!yFolders) return '';
                if(yIndex < 0 || yIndex >= yFolders.length) return '';
                var yFolder = yFolders[yIndex];

                return 'tiles/zoom.'+z+'/'+xFolder+'/'+yFolder+'/tile.0.0.png';
            }
        });

        new tileLayer({
            tileSize: 256,
            maxZoom: 3,
            minZoom: 0,
            noWrap: true,
            bounds: bounds
        }).addTo(map);

        // 4. Load roads and build routing graph
        var roadLayer = L.layerGroup().addTo(map);
        var routingGraph = [];

        fetch('roads.geojson')
        .then(res => res.json())
        .then(data => {
            data.features.forEach(feature => {
                var props = feature.properties;

                if(props.Type === 'Walkway') return;

                var coords = feature.geometry.coordinates.map(c => qgisToLeaflet(c[0], c[1]));
                var speed = props.Speed || 60;

                routingGraph.push({
                    coords: coords,
                    speed: speed,
                    level: props.Level,
                    path: props.Path,
                    name: props.Name,
                    type: props.Type
                });

                // Determine styling
                var color = 'gray';
                var weight = 2;

                if(props.Type === 'Highway' || props.Type === 'Ramp'){
                    color = 'yellow';
                    weight = 6;
                } else if(props.Type === 'Arterial' || props.Type === 'Road'){
                    color = 'white';
                    weight = 4;
                } else if(props.Type === 'Street'){
                    color = 'gray';
                    weight = 2;
                }

                L.polyline(coords, {color: color, weight: weight})
                 .bindPopup('<b>' + props.Name + '</b><br>' +
                            'Type: ' + props.Type + '<br>' +
                            'Level: ' + props.Level + '<br>' +
                            'Path: ' + props.Path + '<br>' +
                            'Speed: ' + speed)
                 .addTo(roadLayer)
                 .bindTooltip(props.Name, {permanent:false, direction:'top'});
            });

            console.log("Routing graph ready:", routingGraph);
        });

        // 5. Load POIs (properties.geojson)
        var poiLayer = L.layerGroup().addTo(map);
        var routeLayer = L.layerGroup().addTo(map);

        // Compute centroid for polygon features
        function polygonCentroid(coords) {
            var ring = coords[0];
            var xSum = 0, ySum = 0;
            ring.forEach(c => { xSum += c[0]; ySum += c[1]; });
            return [ xSum / ring.length, ySum / ring.length ];
        }

        fetch('properties.geojson')
        .then(res => res.json())
        .then(data => {
            data.features.forEach(feature => {
                var props = feature.properties;
                var geom = feature.geometry;

                var coord;
                if (geom.type === "Polygon") {
                    var centroid = polygonCentroid(geom.coordinates);
                    coord = qgisToLeaflet(centroid[0], centroid[1]);

                    // Draw the polygon itself
                    var latlngs = geom.coordinates[0].map(c => qgisToLeaflet(c[0], c[1]));
                    L.polygon(latlngs, {
                        color: 'blue',
                        weight: 2,
                        fillColor: 'blue',
                        fillOpacity: 0.2
                    })
                    .bindPopup('<b>' + props.Name + '</b><br>' +
                               'Address: ' + props.Address + '<br>' +
                               'Type: ' + props.Type + '<br>' +
                               'Level: ' + props.Level + '<br>' +
                               'Street Number: ' + props['Street Number'])
                    .addTo(poiLayer);

                } else if (geom.type === "Point") {
                    coord = qgisToLeaflet(geom.coordinates[0], geom.coordinates[1]);
                } else {
                    return; // skip unsupported geometry types
                }

                if (isNaN(coord[0]) || isNaN(coord[1])) return;

                // Centroid marker for click-to-route and tooltip
                var marker = L.circleMarker(coord, {radius:5, color:'red', fillOpacity:0.8})
                    .bindPopup('<b>' + props.Name + '</b><br>' +
                               'Address: ' + props.Address + '<br>' +
                               'Type: ' + props.Type + '<br>' +
                               'Level: ' + props.Level + '<br>' +
                               'Street Number: ' + props['Street Number'])
                    .addTo(poiLayer)
                    .bindTooltip(props.Name, {permanent:false, direction:'top'});

                marker.on('click', function(){
                    var nearestRoad = findNearestRoad(coord);
                    if(nearestRoad){
                        routeLayer.clearLayers();
                        L.polyline(nearestRoad.coords, {color:'orange', weight:4})
                         .addTo(routeLayer);
                    }
                });
            });
        });

        // 6. Utility: Euclidean distance
        function distance(p1, p2){
            var dx = p1[1] - p2[1];
            var dy = p1[0] - p2[0];
            return Math.sqrt(dx*dx + dy*dy);
        }

        // 7. Find nearest valid road
        function findNearestRoad(coord){
            var candidates = routingGraph.filter(r => 
                ['Street','Arterial','Road','Highway','Ramp'].includes(r.type)
            );

            var primary = candidates.filter(r => ['Street','Arterial','Road'].includes(r.type));
            if(primary.length) candidates = primary;

            var nearest = null;
            var minDist = Infinity;

            candidates.forEach(r => {
                r.coords.forEach(c => {
                    var d = distance(coord, c);
                    if(d < minDist){
                        minDist = d;
                        nearest = r;
                    }
                });
            });

            return nearest;
        }

        // 8. Click-to-route on map
        map.on('click', function(e){
            routeLayer.clearLayers();
            var clicked = [e.latlng.lat, e.latlng.lng];
            var nearestRoad = findNearestRoad(clicked);

            if(nearestRoad){
                L.polyline(nearestRoad.coords, {color:'orange', weight:4})
                 .addTo(routeLayer);
            }
        });

    }); // end tiles load
}; // end window.onload
</script>

</body>
</html>
