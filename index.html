<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>MKB City Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>

<style>
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #000;
  }
  #map {
    width: 100%;
    height: 100%;
  }
  .poi-popup { font-size: 13px; line-height: 1.2; }
</style>
</head>

<body>
<div id="map"></div>

<script>
window.onload = function() {

  // --------------------------
  // Configuration
  // --------------------------
  const MIN_ZOOM = 0;
  const MAX_ZOOM = 3;

  // GitHub Pages repo folder
  const REPO_NAME = '/mkbcity';

  // From QGIS canvas size
  const MAP_WIDTH = 14208;
  const MAP_HEIGHT = 14336;
  const bounds = [[0,0], [MAP_HEIGHT, MAP_WIDTH]];

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: MIN_ZOOM,
    maxZoom: MAX_ZOOM,
    center: [MAP_HEIGHT/2, MAP_WIDTH/2],
    zoom: MIN_ZOOM
  });

  map.fitBounds(bounds);

  function qgisToLeaflet(x, y) { 
    return [MAP_HEIGHT - y, x]; 
  }

  // --------------------------
  // Load tiles_lookup.json
  // --------------------------
  fetch(REPO_NAME + '/tiles_lookup.json')
    .then(r => {
      if (!r.ok) throw new Error("tiles_lookup.json failed: " + r.status);
      return r.json();
    })
    .then(tilesLookup => {

      function regionExists(z, rx, rz) {
        const zKey = String(z);
        if (!tilesLookup[zKey]) return false;
        const rxKey = String(rx);
        const rzKey = String(rz);
        if (!tilesLookup[zKey][rxKey]) return false;
        return tilesLookup[zKey][rxKey].includes(rzKey);
      }

      // --------------------------
      // uNmINeD tile loader
      // --------------------------
      const UnminedTileLayer = L.TileLayer.extend({
        getTileUrl: function(coords) {
          const z = coords.z;
          const tileX = coords.x;
          const tileY = coords.y;

          const regionX = Math.floor(tileX / 10);
          const regionZ = Math.floor(tileY / 10);

          if (!regionExists(z, regionX, regionZ)) {
            return '';
          }

          return (
            REPO_NAME +
            '/tiles/zoom.' + z + '/' +
            regionX + '/' +
            regionZ + '/tile.' +
            tileX + '.' + tileY + '.png'
          );
        }
      });

      new UnminedTileLayer({
        tileSize: 256,
        minZoom: MIN_ZOOM,
        maxZoom: MAX_ZOOM,
        noWrap: true,
        bounds: bounds
      }).addTo(map);

      // --------------------------
      // Roads
      // --------------------------
      const roadLayer = L.layerGroup().addTo(map);
      const routingGraph = [];

      fetch(REPO_NAME + '/roads.geojson')
        .then(r => r.json())
        .then(geo => {
          geo.features.forEach(f => {
            const props = f.properties || {};
            if (props.Type === "Walkway") return;

            const rawCoords = f.geometry.coordinates;
            const latlngs = rawCoords.map(c => qgisToLeaflet(c[0], c[1]));

            const speed = props.Speed || 60;

            routingGraph.push({
              coords: latlngs,
              speed: speed,
              level: props.Level,
              path: props.Path,
              name: props.Name,
              type: props.Type
            });

            let color = "gray", weight = 2;
            if (["Highway","Ramp"].includes(props.Type)) {
              color = "yellow"; weight = 6;
            } else if (["Arterial","Road"].includes(props.Type)) {
              color = "white"; weight = 4;
            }

            L.polyline(latlngs, { color, weight })
              .bindPopup(
                `<div class="poi-popup">
                  <b>${props.Name || ''}</b><br>
                  Type: ${props.Type || ''}<br>
                  Level: ${props.Level || ''}<br>
                  Path: ${props.Path || ''}<br>
                  Speed: ${speed}
                </div>`
              )
              .addTo(roadLayer)
              .bindTooltip(props.Name || '', { direction: "top" });
          });
          console.log("Routing graph nodes:", routingGraph.length);
        });

      // --------------------------
      // POIs
      // --------------------------
      const poiLayer = L.layerGroup().addTo(map);
      const routeLayer = L.layerGroup().addTo(map);

      function polygonCentroid(coords) {
        const ring = coords[0];
        let sx = 0, sy = 0;
        ring.forEach(c => { sx += c[0]; sy += c[1]; });
        return [sx/ring.length, sy/ring.length];
      }

      fetch(REPO_NAME + '/properties.geojson')
        .then(r => r.json())
        .then(geo => {
          geo.features.forEach(feature => {
            const props = feature.properties || {};
            const geom = feature.geometry;
            if (!geom) return;

            let centroidXY = null;

            if (geom.type === "Polygon") {
              centroidXY = polygonCentroid(geom.coordinates);
              const latlngs = geom.coordinates[0].map(c => qgisToLeaflet(c[0], c[1]));
              L.polygon(latlngs, { color:"blue", weight:2, fillColor:"blue", fillOpacity:0.2 })
                .bindPopup(
                  `<div class="poi-popup">
                     <b>${props.Name || ''}</b><br>
                     Address: ${props.Address || ''}<br>
                     Type: ${props.Type || ''}
                   </div>`
                )
                .addTo(poiLayer);
            }

            if (geom.type === "Point") {
              centroidXY = geom.coordinates;
            }

            if (!centroidXY) return;
            const coord = qgisToLeaflet(centroidXY[0], centroidXY[1]);

            const marker = L.circleMarker(coord, { radius:5, color:"red", fillOpacity:0.9 })
              .bindPopup(
                `<div class="poi-popup">
                   <b>${props.Name || ''}</b><br>
                   Address: ${props.Address || ''}<br>
                   Type: ${props.Type || ''}
                 </div>`
              )
              .addTo(poiLayer)
              .bindTooltip(props.Name || '', { direction:"top" });

            marker.on("click", () => {
              const near = findNearestRoad(coord);
              if (near) {
                routeLayer.clearLayers();
                L.polyline(near.coords, { color:"orange", weight:4 })
                  .addTo(routeLayer);
              }
            });
          });
        });

      // --------------------------
      // Nearest road search
      // --------------------------
      function distance(p1, p2){
        const dx = p1[1] - p2[1];
        const dy = p1[0] - p2[0];
        return Math.sqrt(dx*dx + dy*dy);
      }

      function findNearestRoad(coord){
        if (!routingGraph.length) return null;

        let candidates = routingGraph.filter(r =>
          ["Street","Arterial","Road","Highway","Ramp"].includes(r.type)
        );

        let primary = candidates.filter(r =>
          ["Street","Arterial","Road"].includes(r.type)
        );
        if (primary.length) candidates = primary;

        let nearest = null;
        let minDist = Infinity;

        candidates.forEach(r => {
          r.coords.forEach(c => {
            const d = distance(coord, c);
            if (d < minDist) {
              minDist = d;
              nearest = r;
            }
          });
        });

        return nearest;
      }

      map.on("click", e => {
        routeLayer.clearLayers();
        const clicked = [e.latlng.lat, e.latlng.lng];
        const nearest = findNearestRoad(clicked);
        if (nearest)
          L.polyline(nearest.coords, { color:"orange", weight:4 })
            .addTo(routeLayer);
      });

    });

};
</script>
</body>
</html>
